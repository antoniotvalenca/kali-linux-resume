INFORMATION GATHERING:

1) Pasta para cada aplicação alvo

2) dnsenum site.com
    -> guarda dentro da pasta dentro de um dnsenum.txt

3) dar um whois nos ips que vieram para confirmar se possui algum tipo de cloudflare pela frente
    -> salva num arquivo

4) checa se tem algum web application firewall
    -> warw00f http://site.com
    -> salva num arquivo

5) port scanning
    -> nmap <dominio/ip> -sS -sV (sS -> syn scan / sV -> mostra as versoes do serviço que estao rodando)
    -> salva

____________________________________________________________________________________________________________________________________________

TESTANDO UMA APLICAÇÃO

1) SQLi
    -> primeiro, procurar qualquer entrada de dados (formulários, buscas) que renderizem coisas que serão procuradas no banco de dados
    -> formulários de autenticação
        => A) abrir burpsuit e interceptar a requisição de autenticação e mandar para o repeater
        => B) Ao interceptar, no payload colocar uma aspas simples após o email para ver qual será o erro logado no header de resposta
            => o erro pode (ou não) logar várias coisas comprometedoras, como o tipo do banco de dados (que pode ser futuramente usado no sqlmap)
            => ex: { "email":"fulaninho@gmail.com'" ... }
        => C) depois, no repeater, realizar a mesma requisição mas, dessa vez, colocando dois -- após as aspas simples
            => isso estará (a princípio, num sistema fraco) dizendo ao banco para ignorar tudo que vem depois do --, já que esse é o parametro de
            comentário numa query SQL (ou seja, estará dizendo que tudo depois do email não será considerado e todo o processo de autenticação de senha
            seria irrelevante, já que bastaria o email estar correto)
            => ex: { "email": "fulaninho@gmail.com'--"}
            => obs: caso funcione mesmo, da pra fazer sem ser pelo burpsuit, so passar o email@email.com'-- e colocar qualquer senha
    -> url que realizam querys de busca
        => ex: site.com/rest/products/search?q=...
        => interceptando a requisição, no header, podemos alterar o parametro passado no "q=" para ver a resposta do servidor diante disso
        => normalmente, uma query SQL que busca algo especifico : SELECT * FROM Tabela WHERE ((name LIKE 'nome da pessoa')) OU ... LIKE 'nome da pessoa%'))
        em que o "%" seria um caractere curinga que diz para procurar o nome da pessoa + qualquer caracter seguinte (ou seja se o nome for antonio valença e
        eu colocar antonio% o antonio valença será achado)
        => entao poderiamos brincar com isso:
            => NA REQUISIÇÃO DE BUSCA:
            A) GET /rest/products/search?q=banana%'))+ORDER+BY+1-- // vai testando o numero apos BY ate retornar um erro (que vai indicar que nao existe tal num de colunas)
            B) GET /rest/products/search?q=banana%'))+UNION+ALL+SELECT+1,2,3,4,5,6..-- // o numero é igual ao total de colunas
    -> ou podemos simplsmente usar SQLPMAP: sqlmap -u "http://site.com/erst/products/search?q=34" --dbms=sqlite --level 2 (..)