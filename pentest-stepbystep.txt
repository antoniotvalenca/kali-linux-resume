INFORMATION GATHERING:

1) Pasta para cada aplicação alvo

2) dnsenum site.com
    -> guarda dentro da pasta dentro de um dnsenum.txt

3) dar um whois nos ips que vieram para confirmar se possui algum tipo de cloudflare pela frente
    -> salva num arquivo

4) checa se tem algum web application firewall
    -> warw00f http://site.com
    -> salva num arquivo

5) port scanning
    -> nmap <dominio/ip> -sS -sV (sS -> syn scan / sV -> mostra as versoes do serviço que estao rodando)
    -> salva

____________________________________________________________________________________________________________________________________________

TESTANDO UMA APLICAÇÃO

1) SQLi
    -> primeiro, procurar qualquer entrada de dados (formulários, buscas) que renderizem coisas que serão procuradas no banco de dados
    -> formulários de autenticação
        => A) abrir burpsuit e interceptar a requisição de autenticação e mandar para o repeater
        => B) Ao interceptar, no payload colocar uma aspas simples após o email para ver qual será o erro logado no header de resposta
            => o erro pode (ou não) logar várias coisas comprometedoras, como o tipo do banco de dados (que pode ser futuramente usado no sqlmap)
            => ex: { "email":"fulaninho@gmail.com'" ... }
        => C) depois, no repeater, realizar a mesma requisição mas, dessa vez, colocando dois -- após as aspas simples
            => isso estará (a princípio, num sistema fraco) dizendo ao banco para ignorar tudo que vem depois do --, já que esse é o parametro de
            comentário numa query SQL (ou seja, estará dizendo que tudo depois do email não será considerado e todo o processo de autenticação de senha
            seria irrelevante, já que bastaria o email estar correto)
            => ex: { "email": "fulaninho@gmail.com'--"}
            => obs: caso funcione mesmo, da pra fazer sem ser pelo burpsuit, so passar o email@email.com'-- e colocar qualquer senha
    -> url que realizam querys de busca
        => ex: site.com/rest/products/search?q=...
        => interceptando a requisição, no header, podemos alterar o parametro passado no "q=" para ver a resposta do servidor diante disso
        => normalmente, uma query SQL que busca algo especifico : SELECT * FROM Tabela WHERE ((name LIKE 'nome da pessoa')) OU ... LIKE 'nome da pessoa%'))
        em que o "%" seria um caractere curinga que diz para procurar o nome da pessoa + qualquer caracter seguinte (ou seja se o nome for antonio valença e
        eu colocar antonio% o antonio valença será achado)
        => entao poderiamos brincar com isso:
            => NA REQUISIÇÃO DE BUSCA:
            A) GET /rest/products/search?q=banana%'))+ORDER+BY+1-- // vai testando o numero apos BY ate retornar um erro (que vai indicar que nao existe tal num de colunas)
            B) GET /rest/products/search?q=banana%'))+UNION+ALL+SELECT+1,2,3,4,5,6..-- // o numero é igual ao total de colunas
    -> ou podemos simplsmente usar SQLPMAP: sqlmap -u "http://site.com/erst/products/search?q=34" --dbms=sqlite --level 2 (..)

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

2) XSS
    1) Normalmente sabemos que uma aplicação é sensível à script quando ela é sensível, também, à html injection (DOM/REFLECTED)
        -> ir em algum lugar/url de entrada de dados e testar inserir tags
        -> ex: site.com/search?q=produto<input>
            -> se o input for renderizado, é sensível (provavelmente) à scripts maliciosos
            -> algumas vezes esse script vai dar erro (ja que algumas vezes a tag script vai ser tratada como um texto do html), mas existem outras maneiras de
            se aproveitar de html injection para usar scripts, geralmente utilizando os eventos do DOM (document object model) (eventos que sao chamados após
            algum acontecimentos, como erros)
                -> site.com/search?q=produto<img src=x>
                    -> obviamente dará um erro, já que a source da imagem é vazia
                    -> portanto, podemos aproveitar o evento de onerror do DOM para inserir um script
                -> site.com/search?q=produto<img src=x onerror="alert(1)"> // por exemplo
                    -> podemos, no onerror, colocar um codigo malicioso e enviar para uma pessoa, que sofrerá as consequencias desse codigo malicioso
                        -> ex: document.cookie que absorve o cookie de autenticacao

    2) Também podemos testar o XSS em inputs que guardam algo na aplicação (comentarios, etc) (STORED)
        -> A) <script> alert(1) </script>
        -> B) <script<script>alert(1)</script>>
        -> C) <<script>TESTE</script>iframe src="javascript:alert('xss')">
            -> ir testando possibilidades de inserção de script

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

3) XXE
    1) Primeiramente, procurar partes do site que pedem upload de arquivo
        -> os sites geralmente só aceitam tipos específicos de arquivo (pdf, etc)
        -> as verificações, às vezes, são feitas apenas no clientside (ou seja):
        -> se você interceptar a requisição e mudar a extensão no header interceptado, pode (ou não) funcionar

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
